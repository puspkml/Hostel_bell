import type { Actions } from "@sveltejs/kit";
import axios from "axios";

export const actions = {
  default: async ({ request }) => {
    try {
      // Get form data
      const formData = await request.formData();
      const data: Record<string, string> = {};
      formData.forEach((value, key) => {
        data[key] = value.toString();
      });

      console.log('Form Data Received:', {
        name: data.name,
        startDate: data.startDate,
        endDate: data.endDate,
        time: data.time,
        bell_type: data.bell_type,  // Updated to bell_type
        days: data.days
      });

      // Validate all required fields
      if (!data.name || !data.startDate || !data.endDate || !data.time || !data.days || data.bell_type === undefined) {
        return { success: false, message: 'All fields are required.' };
      }

      // Validate bell_type (must be 0, 1, or 2)
      const bellTypeInt = parseInt(data.bell_type, 10);
      if (isNaN(bellTypeInt) || ![0, 1, 2].includes(bellTypeInt)) {
        return { success: false, message: 'Bell type must be 0 (Supravatam first bell), 1 (Supravatam second bell), or 2 (Normal).' };
      }

      let parsedDays: number[];

      try {
        // Parse JSON and convert to numbers (handles string array like ["0","2"] → [0,2])
        const rawDays = JSON.parse(data.days);
        if (!Array.isArray(rawDays)) {
          throw new Error('Must be an array.');
        }
        parsedDays = rawDays.map((d: string | number) => Number(d)).filter((d: number) => !isNaN(d));
        
        if (parsedDays.length === 0) {
          throw new Error('Must be a non-empty array of numbers (0=Monday to 6=Sunday).');
        }
        // Validate days are valid weekday integers (0-6)
        if (!parsedDays.every((d: number) => Number.isInteger(d) && d >= 0 && d <= 6)) {
          throw new Error('Days must be integers between 0 (Monday) and 6 (Sunday).');
        }
        // Remove duplicates (e.g., if somehow selected twice)
        parsedDays = [...new Set(parsedDays)];
      } catch (e: any) {
        console.error('Days parsing error:', e, 'Raw days:', data.days);
        return { success: false, message: `Invalid days format: ${e.message}. Ensure you select weekdays (Mon-Sun).` };
      }

      console.log('Parsed and validated days:', parsedDays);  // Debug log

      // Basic date validation (Flask will handle the rest, but prevent bad inputs)
      let startDateObj: Date;
      let endDateObj: Date;
      try {
        startDateObj = new Date(data.startDate + 'T00:00:00');
        endDateObj = new Date(data.endDate + 'T23:59:59');
        if (isNaN(startDateObj.getTime()) || isNaN(endDateObj.getTime())) {
          throw new Error('Invalid date format.');
        }
      } catch (e) {
        return { success: false, message: 'Invalid date format. Use YYYY-MM-DD.' };
      }
      if (startDateObj > endDateObj) {
        return { success: false, message: 'Start date must be before or equal to end date.' };
      }

      // Optional: Rough estimate of potential events (for logging/debugging; Flask computes exactly)
      const daysInRange = Math.ceil((endDateObj.getTime() - startDateObj.getTime()) / (1000 * 60 * 60 * 24)) + 1;
      const potentialEvents = Math.floor(daysInRange / 7) * parsedDays.length + (daysInRange % 7 > 0 ? parsedDays.length : 0);
      console.log(`Potential events estimate: ~${potentialEvents} (range: ${daysInRange} days, selected days: ${parsedDays.length})`);
      if (potentialEvents === 0) {
        return { success: false, message: 'Date range is too short—no events possible. Extend the range or select more days.' };
      }

      // Send the data to Flask backend (updated to send bell_type)
      try {
        const response = await axios.post('http://localhost:5000/schedules', {
          name: data.name,
          bell_type: bellTypeInt,  // Send as integer
          startDate: data.startDate,
          endDate: data.endDate,
          time: data.time,
          days: parsedDays  // Now guaranteed integers [0,2,...]
        });

        if (response.status !== 200) {
          console.error('Flask error:', response.statusText);
          return { success: false, message: 'Flask backend rejected the data. Check server logs.' };
        }

        // Flask doesn't return the number of events, but we can estimate/log it
        console.log(`Successfully sent to Flask. Expected ~${potentialEvents} events generated by backend.`);
        return {
          success: true,
          message: 'Schedule successfully added! Check Flask logs for generated events.'
        };
      } catch (err: any) {
        console.error('Error sending to Flask:', err);
        return { success: false, message: `Error contacting Flask backend: ${err.response?.data?.message || err.message || 'Unknown error'}` };
      }

    } catch (error: any) {
      console.error('Unexpected error:', error);
      return { success: false, message: `Unexpected error: ${error.message || error}` };
    }
  },
} satisfies Actions;
